import React from 'react';
import { TransactionStatus, TransactionType } from '@anterapp/transaction-controller';
import { getMockConfirmState } from '../../../test/data/confirmations/helper';
import { renderWithConfirmContextProvider } from '../testlib';
import { fireEvent, renderWithStoreAndRouter } from 'test-helpers';
import * as Actions from 'store/actions';
const configureStore = () => store; // assuming store is defined in the parent file or imported earlier in the same file, adjust accordingly for an external import case like below: `const configureStore = require('store')`;
// import store from "store"; // for external file import of Store module and using it here directly or through a variable reference (e.g let store) if necessary after declaring it above `configureStore()` function call with a new scope in the respective file where this code snippet would be included, e.g configuring it to accept and return a predefined mocked state like below: `export const configureStore = (mockData) => ({ …… })`, which can then be used within `renderWithConfirmContextProvider` and other test functions that use this mock data or another method to create a testing environment similar to an actual application instance running locally for development purposes before deploying to production servers due to security concerns regarding shared keys or sensitive data exposure when handling real user transactions involving cryptocurrency transactions requiring personal user information such as wallet addresses etc which are prone to potential security risks when handling live accounts rather than just running tests in isolation without any real users interacting with them during development phases unless absolutely necessary under controlled conditions only then using secure encrypted communication channels such as https instead of http protocol when accessing web3 provider endpoints etc depending on specific project requirements
